"""
Orders API routes
------------------

This module defines all endpoints for working with orders within the
application. Orders represent purchases made by customers and include
information such as the order number, customer name, order date, status,
total amount and payment status. In addition to basic CRUD operations,
the API exposes bulk operations for updating statuses, duplicating
orders and deleting multiple orders at once.
"""

from typing import List, Optional

from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel, Field

from app.database import get_db

router = APIRouter(prefix="/orders", tags=["orders"])


class OrderBase(BaseModel):
    order_number: str = Field(..., description="Human friendly order identifier (e.g. #ORD1001)")
    customer_name: str = Field(..., description="Name of the customer who placed the order")
    order_date: str = Field(..., description="Date of the order in YYYY-MM-DD format")
    status: str = Field(..., description="Current status of the order (Pending, Completed, Refunded, etc.)")
    total_amount: float = Field(..., description="Total price of the order")
    payment_status: str = Field(..., description="Payment state (Paid, Unpaid)")


class OrderCreate(OrderBase):
    """Schema for creating a new order."""


class OrderUpdate(BaseModel):
    """Schema for updating an existing order.

    All fields are optional to allow partial updates.
    """

    order_number: Optional[str] = Field(None, description="Human friendly order identifier (e.g. #ORD1001)")
    customer_name: Optional[str] = Field(None, description="Name of the customer who placed the order")
    order_date: Optional[str] = Field(None, description="Date of the order in YYYY-MM-DD format")
    status: Optional[str] = Field(None, description="Current status of the order")
    total_amount: Optional[float] = Field(None, description="Total price of the order")
    payment_status: Optional[str] = Field(None, description="Payment state (Paid, Unpaid)")


class OrderResponse(OrderBase):
    """Response schema including the autogenerated primary key."""

    id: int


# Payload schemas for bulk operations
class BulkStatusUpdate(BaseModel):
    """Request body for bulk status update."""
    order_ids: List[int] = Field(..., description="List of order IDs to update")
    status: str = Field(..., description="New status to apply to the selected orders")


class BulkIds(BaseModel):
    """Request body for operations that only need a list of order IDs."""
    order_ids: List[int] = Field(..., description="List of order IDs")


@router.get("")
def list_orders(
    status: Optional[str] = Query(None, description="Filter orders by status"),
    page: int = Query(1, ge=1, description="Page number for pagination"),
    limit: int = Query(10, ge=1, le=100, description="Number of items per page"),
):
    """List orders with optional status filter and pagination.

    Args:
        status (Optional[str]): Filter by order status (e.g. 'Pending').
        page (int): Page number starting from 1.
        limit (int): Number of items per page.

    Returns:
        dict: A dictionary containing a list of orders and pagination details.
    """
    offset = (page - 1) * limit
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            # Build base query and parameters
            base_query = "SELECT id, order_number, customer_name, order_date, status, total_amount, payment_status FROM orders"
            params: List[object] = []
            if status:
                base_query += " WHERE status = ?"
                params.append(status)
            # Fetch total count for pagination
            count_query = f"SELECT COUNT(*) as count FROM (" + base_query + ")"
            cursor.execute(count_query, params)
            total_count = cursor.fetchone()["count"]
            # Append ordering, limit and offset
            base_query += " ORDER BY id LIMIT ? OFFSET ?"
            params.extend([limit, offset])
            cursor.execute(base_query, params)
            rows = cursor.fetchall()
            orders = [
                {
                    "id": row["id"],
                    "order_number": row["order_number"],
                    "customer_name": row["customer_name"],
                    "order_date": row["order_date"],
                    "status": row["status"],
                    "total_amount": row["total_amount"],
                    "payment_status": row["payment_status"],
                }
                for row in rows
            ]
            return {
                "items": orders,
                "page": page,
                "limit": limit,
                "total": total_count,
            }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@router.get("/stats")
def get_order_stats():
    """Return counts of orders grouped by status.

    Useful for populating summary cards on the frontend.
    """
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT status, COUNT(*) AS count FROM orders GROUP BY status"
            )
            stats = {row["status"]: row["count"] for row in cursor.fetchall()}
            return stats
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@router.get("/{order_id}")
def get_order(order_id: int):
    """Retrieve a single order by its ID."""
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT id, order_number, customer_name, order_date, status, total_amount, payment_status FROM orders WHERE id = ?",
                (order_id,),
            )
            row = cursor.fetchone()
            if row is None:
                raise HTTPException(status_code=404, detail="Order not found")
            return {
                "id": row["id"],
                "order_number": row["order_number"],
                "customer_name": row["customer_name"],
                "order_date": row["order_date"],
                "status": row["status"],
                "total_amount": row["total_amount"],
                "payment_status": row["payment_status"],
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@router.post("", status_code=201)
def create_order(order: OrderCreate):
    """Create a new order."""
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO orders (order_number, customer_name, order_date, status, total_amount, payment_status) "
                "VALUES (?, ?, ?, ?, ?, ?)",
                (
                    order.order_number,
                    order.customer_name,
                    order.order_date,
                    order.status,
                    order.total_amount,
                    order.payment_status,
                ),
            )
            order_id = cursor.lastrowid
            return {
                "id": order_id,
                "order_number": order.order_number,
                "customer_name": order.customer_name,
                "order_date": order.order_date,
                "status": order.status,
                "total_amount": order.total_amount,
                "payment_status": order.payment_status,
            }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@router.put("/{order_id}")
def update_order(order_id: int, order: OrderUpdate):
    """Update an existing order."""
    # Build dynamic update query based on provided fields
    fields = []
    params: List[object] = []
    if order.order_number is not None:
        fields.append("order_number = ?")
        params.append(order.order_number)
    if order.customer_name is not None:
        fields.append("customer_name = ?")
        params.append(order.customer_name)
    if order.order_date is not None:
        fields.append("order_date = ?")
        params.append(order.order_date)
    if order.status is not None:
        fields.append("status = ?")
        params.append(order.status)
    if order.total_amount is not None:
        fields.append("total_amount = ?")
        params.append(order.total_amount)
    if order.payment_status is not None:
        fields.append("payment_status = ?")
        params.append(order.payment_status)

    if not fields:
        raise HTTPException(status_code=400, detail="No fields provided for update")
    
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            # Check if order exists
            cursor.execute("SELECT id FROM orders WHERE id = ?", (order_id,))
            if cursor.fetchone() is None:
                raise HTTPException(status_code=404, detail="Order not found")
            # Execute update
            query = f"UPDATE orders SET {', '.join(fields)} WHERE id = ?"
            params.append(order_id)
            cursor.execute(query, params)
            # Return updated order
            cursor.execute(
                "SELECT id, order_number, customer_name, order_date, status, total_amount, payment_status FROM orders WHERE id = ?",
                (order_id,),
            )
            row = cursor.fetchone()
            return {
                "id": row["id"],
                "order_number": row["order_number"],
                "customer_name": row["customer_name"],
                "order_date": row["order_date"],
                "status": row["status"],
                "total_amount": row["total_amount"],
                "payment_status": row["payment_status"],
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@router.delete("/{order_id}", status_code=204)
def delete_order(order_id: int):
    """Delete an order."""
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            # Check if order exists
            cursor.execute("SELECT id FROM orders WHERE id = ?", (order_id,))
            if cursor.fetchone() is None:
                raise HTTPException(status_code=404, detail="Order not found")
            # Delete the order
            cursor.execute("DELETE FROM orders WHERE id = ?", (order_id,))
            return None
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@router.put("/bulk/status")
def bulk_update_status(payload: BulkStatusUpdate):
    """Bulk update the status of multiple orders.

    Args:
        payload (BulkStatusUpdate): Request body containing order_ids and new status.

    Returns:
        dict: A message confirming the update and the number of affected rows.
    """
    order_ids = payload.order_ids
    status = payload.status
    if not order_ids:
        raise HTTPException(status_code=400, detail="order_ids must not be empty")
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            placeholders = ",".join(["?"] * len(order_ids))
            query = f"UPDATE orders SET status = ? WHERE id IN ({placeholders})"
            params: List[object] = [status, *order_ids]
            cursor.execute(query, params)
            affected = cursor.rowcount
            return {"updated": affected}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@router.post("/bulk/duplicate")
def bulk_duplicate(payload: BulkIds):
    """Duplicate multiple orders.

    For each order ID provided, this endpoint will create a new order with
    identical fields except for a new unique order number. The new order
    number is derived from the original by appending a "-COPY" suffix along
    with a running index to guarantee uniqueness.

    Args:
        payload (BulkIds): Body containing the list of order IDs to duplicate.

    Returns:
        dict: A dictionary with a list of newly created orders.
    """
    order_ids = payload.order_ids
    if not order_ids:
        raise HTTPException(status_code=400, detail="order_ids must not be empty")
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            # Fetch original orders
            placeholders = ",".join(["?"] * len(order_ids))
            cursor.execute(
                f"SELECT id, order_number, customer_name, order_date, status, total_amount, payment_status FROM orders WHERE id IN ({placeholders})",
                order_ids,
            )
            originals = cursor.fetchall()
            if not originals:
                raise HTTPException(status_code=404, detail="No orders found to duplicate")
            new_orders = []
            # Counter to ensure unique suffix across duplicates
            suffix_counter = 1
            for row in originals:
                base_number = row["order_number"]
                new_number = f"{base_number}-COPY"
                # Ensure new_number is unique
                while True:
                    cursor.execute("SELECT 1 FROM orders WHERE order_number = ?", (new_number,))
                    if cursor.fetchone() is None:
                        break
                    suffix_counter += 1
                    new_number = f"{base_number}-COPY{suffix_counter}"
                # Insert duplicated order
                cursor.execute(
                    "INSERT INTO orders (order_number, customer_name, order_date, status, total_amount, payment_status) "
                    "VALUES (?, ?, ?, ?, ?, ?)",
                    (
                        new_number,
                        row["customer_name"],
                        row["order_date"],
                        row["status"],
                        row["total_amount"],
                        row["payment_status"],
                    ),
                )
                new_id = cursor.lastrowid
                new_orders.append(
                    {
                        "id": new_id,
                        "order_number": new_number,
                        "customer_name": row["customer_name"],
                        "order_date": row["order_date"],
                        "status": row["status"],
                        "total_amount": row["total_amount"],
                        "payment_status": row["payment_status"],
                    }
                )
            return {"orders": new_orders}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@router.delete("/bulk", status_code=204)
def bulk_delete(payload: BulkIds):
    """Delete multiple orders at once."""
    order_ids = payload.order_ids
    if not order_ids:
        raise HTTPException(status_code=400, detail="order_ids must not be empty")
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            placeholders = ",".join(["?"] * len(order_ids))
            cursor.execute(f"DELETE FROM orders WHERE id IN ({placeholders})", order_ids)
            return None
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")